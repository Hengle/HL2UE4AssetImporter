#pragma once;

#include "CoreMinimal.h"
#include "utils.h"
#include "compressed_vector.h"

namespace Valve
{
	namespace MDL
	{
		constexpr int MAX_NUM_LODS = 8;

		enum class studiohdr_flag : int
		{
			// This flag is set if no hitbox information was specified
			AUTOGENERATED_HITBOX = 1 << 0,
			// This flag is set at loadtime, not mdl build time so that we don't have to rebuild models when we change materials.
			USES_ENV_CUBEMAP = 1 << 1,
			// Use this when there are translucent parts to the model but we're not going to sort it.
			FORCE_OPAQUE = 1 << 2,
			// Use this when we want to render the opaque parts during the opaque pass and the translucent parts during the translucent pass.Added using $mostlyopaque to the QC.
			TRANSLUCENT_TWOPASS = 1 << 3,
			// This is set any time the.qc files has $staticprop in it.Means there's no bones and no transforms.
			STATIC_PROP = 1 << 4,
			// This flag is set at loadtime, not mdl build time so that we don't have to rebuild models when we change materials.
			USES_FB_TEXTURE = 1 << 5,
			// This flag is set by studiomdl.exe if a separate "$shadowlod" entry was present for the.mdl(the shadow lod is the last entry in the lod list if present).
			HASSHADOWLOD = 1 << 6,
			// This flag is set at loadtime, not mdl build time so that we don't have to rebuild models when we change materials.
			USES_BUMPMAPPING = 1 << 7,
			// This flag is set when we should use the actual materials on the shadow LOD instead of overriding them with the default one(necessary for translucent shadows).
			USE_SHADOWLOD_MATERIALS = 1 << 8,
			OBSOLETE = 1 << 9,
			UNUSED = 1 << 10,
			// This flag is set at mdl build time.
			NO_FORCED_FADE = 1 << 11,
			// The npc will lengthen the viseme check to always include two phonemes.
			FORCE_PHONEME_CROSSFADE = 1 << 12,
			// This flag is set when the.qc has $constantdirectionallight in it.If set, we use constantdirectionallightdot to calculate light intensity rather than the normal directional dot product.Only valid if STUDIOHDR_FLAGS_STATIC_PROP is also set.
			CONSTANT_DIRECTIONAL_LIGHT_DOT = 1 << 13,
			// Flag to mark delta flexes as already converted from disk format to memory format.
			FLEXES_CONVERTED = 1 << 14,
			// Indicates the studiomdl was built in preview mode(added with the - preview flag).
			BUILT_IN_PREVIEW_MODE = 1 << 15,
			// Ambient boost(runtime flag).
			AMBIENT_BOOST = 1 << 16,
			// Don't cast shadows from this model (useful on first-person models).
			DO_NOT_CAST_SHADOWS = 1 << 17,
			// Alpha textures should cast shadows in vrad on this model(ONLY prop_static!).Requires setup in the lights.rad file.
			CAST_TEXTURE_SHADOWS = 1 << 18
		};

		struct mstudiobone_t
		{
			int					sznameindex;
			FString GetName() const { return ReadString(this, sznameindex); }

			int		 			parent;		// parent bone
			int					bonecontroller[6];	// bone controller index, -1 == none

			// default values
			float			pos[3];
			float			quat[4];
			float			rot[3];
			// compression scale
			float				posscale[3];
			float				rotscale[3];

			float			poseToBone[12]; // 3x4 matrix
			float			qAlignment[4];
			int					flags;
			int					proctype;
			int					procindex;		// procedural rule
			int					physicsbone;	// index into physically simulated bone
			int					surfacepropidx;	// index into string tablefor property name
			int					contents;		// See BSPFlags.h for the contents flags

			int					unused[8];		// remove as appropriate
		};

		struct mstudiotexture_t
		{
			// Number of bytes past the beginning of this structure
			// where the first character of the texture name can be found.
			int		name_offset; 	// Offset for null-terminated string
			FString GetName() const { return ReadString(this, name_offset); }

			int		flags;
			int		used; 		// ??

			int		unused0; 	// ??

			int	material;		// Placeholder for IMaterial
			int	client_material;	// Placeholder for void*

			int		unused1[10];
		};

		struct mstudio_modelvertexdata_t
		{
			// base of external vertex data stores
			int pVertexData;
			int pTangentData;
		};

		struct mstudio_meshvertexdata_t
		{
			// indirection to this mesh's model's vertex data
			int modelvertexdata;

			// used for fixup calcs when culling top level lods
			// expected number of mesh verts at desired lod
			int					numLODVertexes[MAX_NUM_LODS];
		};

		struct mstudiomesh_t
		{
			int					material;

			int					modelindex;

			int					numvertices;		// number of unique vertices/normals/texcoords
			int					vertexoffset;		// vertex mstudiovertex_t

			int					numflexes;			// vertex animation
			int					flexindex;
			// inline mstudioflex_t* pFlex(int i) const { return (mstudioflex_t*)(((byte*)this) + flexindex) + i; };

			// special codes for material operations
			int					materialtype;
			int					materialparam;

			// a unique ordinal for this mesh
			int					meshid;

			FVector				center;

			mstudio_meshvertexdata_t vertexdata;

			int					unused[8]; // remove as appropriate
		};

		struct mstudiomodel_t
		{
			char				name[64];
			FString GetName() const { return ReadString(this, 0); }

			int					type;

			float				boundingradius;

			int					nummeshes;
			int					meshindex;
			void GetMeshes(TArray<const mstudiomesh_t*>& out) const { return ReadArray<mstudiomesh_t>(this, meshindex, nummeshes, out); }

			// cache purposes
			int					numvertices;		// number of unique vertices/normals/texcoords
			int					vertexindex;		// vertex Vector
			int					tangentsindex;		// tangents Vector

			int					numattachments;
			int					attachmentindex;

			int					numeyeballs;
			int					eyeballindex;
			// inline  mstudioeyeball_t* pEyeball(int i) { return (mstudioeyeball_t*)(((byte*)this) + eyeballindex) + i; };

			mstudio_modelvertexdata_t vertexdata;

			int					unused[8];		// remove as appropriate
		};

		struct mstudiobodyparts_t
		{
			int					sznameindex;
			FString GetName() const { return ReadString(this, sznameindex); }
			int					nummodels;
			int					base;
			int					modelindex; // index into models array
			void GetModels(TArray<const mstudiomodel_t*>& out) const { return ReadArray<mstudiomodel_t>(this, modelindex, nummodels, out); }
		};

		struct mstudiomovement_t
		{
			int					endframe;
			int					motionflags;
			float				v0;			// velocity at start of block
			float				v1;			// velocity at end of block
			float				angle;		// YAW rotation at end of this blocks movement
			FVector				vector;		// movement vector relative to this blocks initial angle
			FVector				position;	// relative to start of animation???
		};

		union mstudioanimvalue_t
		{
			struct
			{
				uint8	valid;
				uint8	total;
			} num;
			short		value;
		};

		struct mstudioanim_valueptr_t
		{
			short	offset[3];
			const mstudioanimvalue_t* GetAnimValue(int i) const { return offset[i] > 0 ? (const mstudioanimvalue_t*)(((uint8*)this) + offset[i]) : nullptr; };
		};

		enum class mstudioanim_flag : uint8
		{
			RAWPOS = 0x01, // Vector48
			RAWROT = 0x02, // Quaternion48
			ANIMPOS = 0x04, // mstudioanim_valueptr_t
			ANIMROT = 0x08, // mstudioanim_valueptr_t
			ANIMDELTA = 0x10,
			RAWROT2 = 0x20 // Quaternion64
		};

		// per bone per animation DOF and weight pointers
		struct mstudioanim_t
		{
			uint8				bone;
			uint8				flags;		// weighing options
			bool HasFlag(mstudioanim_flag flag) const { return (flags & (int)flag) != 0; }

			const uint8* GetDataPtr() const { return (((uint8*)this) + sizeof(mstudioanim_t)); }

			// valid for animating data only
			const mstudioanim_valueptr_t* GetRotValue() const { return (mstudioanim_valueptr_t*)GetDataPtr(); }
			const mstudioanim_valueptr_t* GetPosValue() const { return (mstudioanim_valueptr_t*)GetDataPtr() + (HasFlag(mstudioanim_flag::ANIMROT) ? 1 : 0); }

			//// valid if animation unvaring over timeline
			const Quaternion48* GetQuat48(void) const { return (Quaternion48*)GetDataPtr(); };
			const Quaternion64* GetQuat64(void) const { return (Quaternion64*)GetDataPtr(); };
			const Vector48* GetPos(void) const { return (Vector48*)(GetDataPtr() + (HasFlag(mstudioanim_flag::RAWROT) ? 1 : 0) * sizeof(Quaternion48) + (HasFlag(mstudioanim_flag::RAWROT2) ? 1 : 0) * sizeof(Quaternion64)); };

			short				nextoffset;
		};

		struct mstudioanimblock_t
		{
			int					datastart;
			int					dataend;
		};

		struct mstudioanimsections_t
		{
			int					animblock;
			int					animindex;
		};

		struct studiohdr_t;

		enum class mstudioanimdesc_flag : int32
		{
			LOOPING = 0x0001,		// ending frame should be the same as the starting frame
			SNAP = 0x0002,		// do not interpolate between previous animation and this one
			ADDDELTA = 0x0004,		// this sequence "adds" to the base sequences, not slerp blends
			AUTOPLAY = 0x0008,		// temporary flag that forces the sequence to always play
			POST = 0x0010,		// 
			ALLZEROS = 0x0020,		// this animation/sequence has no real animation data
			CYCLEPOSE = 0x0080,		// cycle index is taken from a pose parameter index
			REALTIME = 0x0100,		// cycle index is taken from a real-time clock, not the animations cycle index
			LOCAL = 0x0200,		// sequence has a local context sequence
			HIDDEN = 0x0400,		// don't show in default selection views
			OVERRIDE = 0x0800,		// a forward declared sequence (empty)
			ACTIVITY = 0x1000,		// Has been updated at runtime to activity index
			EVENT = 0x2000,		// Has been updated at runtime to event index
			WORLD = 0x4000		// sequence blends in worldspace
		};

		struct mstudioanimdesc_t
		{
			int					baseptr;

			int					sznameindex;
			FString GetName() const { return ReadString(this, sznameindex); }

			float				fps;		// frames per second	
			int					flags;		// looping/non-looping flags
			bool HasFlag(mstudioanimdesc_flag flag) const { return (flags & (int)flag) != 0; }

			int					numframes;

			// piecewise movement
			int					nummovements;
			int					movementindex;
			void GetMovements(TArray<const mstudiomovement_t*>& out) const { return ReadArray<mstudiomovement_t>(this, movementindex, nummovements, out); }

			int					unused1[6];			// remove as appropriate (and zero if loading older versions)	

			int					animblock;
			int					animindex;	 // non-zero when anim data isn't in sections


			int					numikrules;
			int					ikruleindex;	// non-zero when IK data is stored in the mdl
			int					animblockikruleindex; // non-zero when IK data is stored in animblock file
			//mstudioikrule_t* pIKRule(int i) const;

			int					numlocalhierarchy;
			int					localhierarchyindex;
			//mstudiolocalhierarchy_t* pHierarchy(int i) const;

			int					sectionindex;
			int					sectionframes; // number of frames used in each fast lookup section, zero if not used
			void GetSections(TArray<const mstudioanimsections_t*>& out) const { return ReadArray<mstudioanimsections_t>(this, sectionindex, (numframes / sectionframes) + 2, out); }

			short				zeroframespan;	// frames per span
			short				zeroframecount; // number of spans
			int					zeroframeindex;
			//byte* pZeroFrameData() const { if (zeroframeindex) return (((byte*)this) + zeroframeindex); else return NULL; };
			mutable float		zeroframestalltime;		// saved during read stalls
		};

		struct mstudioseqdesc_t
		{
			int					baseptr;

			int					szlabelindex;
			FString GetLabel() const { return szlabelindex > 0 ? ReadString(this, szlabelindex) : FString(); }

			int					szactivitynameindex;
			FString GetActivityName() const { return szactivitynameindex > 0 ? ReadString(this, szactivitynameindex) : FString(); }

			int					flags;		// looping/non-looping flags
			

			int					activity;	// initialized at loadtime to game DLL values
			int					actweight;

			int					numevents;
			int					eventindex;
			//inline mstudioevent_t* pEvent(int i) const { Assert(i >= 0 && i < numevents); return (mstudioevent_t*)(((byte*)this) + eventindex) + i; };

			FVector				bbmin;		// per sequence bounding box
			FVector				bbmax;

			int					numblends;

			// Index into array of shorts which is groupsize[0] x groupsize[1] in length
			int					animindexindex;

			void GetAnimIndices(TArray<TArray<int>>& out) const
			{
				out.AddDefaulted(groupsize[0]);
				short* ptr = (short*)(((uint8*)this) + animindexindex);
				for (int x = 0; x < out.Num(); ++x)
				{
					TArray<int>& arr = out[x];
					arr.Reserve(groupsize[1]);
					for (int y = 0; y < out.Num(); ++y)
					{
						arr.Add((int)ptr[y * groupsize[0] + x]);
					}
				}
			}

			/*inline int			anim(int x, int y) const
			{
				if (x >= groupsize[0])
				{
					x = groupsize[0] - 1;
				}

				if (y >= groupsize[1])
				{
					y = groupsize[1] - 1;
				}

				int offset = y * groupsize[0] + x;
				short* blends = (short*)(((byte*)this) + animindexindex);
				int value = (int)blends[offset];
				return value;
			}*/

			int					movementindex;	// [blend] float array for blended movement
			int					groupsize[2];
			int					paramindex[2];	// X, Y, Z, XR, YR, ZR
			float				paramstart[2];	// local (0..1) starting value
			float				paramend[2];	// local (0..1) ending value
			int					paramparent;

			float				fadeintime;		// ideal cross fate in time (0.2 default)
			float				fadeouttime;	// ideal cross fade out time (0.2 default)

			int					localentrynode;		// transition node at entry
			int					localexitnode;		// transition node at exit
			int					nodeflags;		// transition rules

			float				entryphase;		// used to match entry gait
			float				exitphase;		// used to match exit gait

			float				lastframe;		// frame that should generation EndOfSequence

			int					nextseq;		// auto advancing sequences
			int					pose;			// index of delta animation between end and nextseq

			int					numikrules;

			int					numautolayers;	//
			int					autolayerindex;
			//inline mstudioautolayer_t* pAutolayer(int i) const { Assert(i >= 0 && i < numautolayers); return (mstudioautolayer_t*)(((byte*)this) + autolayerindex) + i; };

			int					weightlistindex;
			inline float		GetWeight(int i) const { return *(((float*)(((uint8*)this) + weightlistindex) + i)); };

			// FIXME: make this 2D instead of 2x1D arrays
			int					posekeyindex;
			float				GetPoseKey(int iParam, int iAnim) const { return *((float*)(((uint8*)this) + posekeyindex) + iParam * groupsize[0] + iAnim); }

			int					numiklocks;
			int					iklockindex;
			//inline mstudioiklock_t* pIKLock(int i) const { Assert(i >= 0 && i < numiklocks); return (mstudioiklock_t*)(((byte*)this) + iklockindex) + i; };

			// Key values
			int					keyvalueindex;
			int					keyvaluesize;
			//inline const char* KeyValueText(void) const { return keyvaluesize != 0 ? ((char*)this) + keyvalueindex : NULL; }

			int					cycleposeindex;		// index of pose parameter to use as cycle index

			int					unused[7];		// remove/add as appropriate (grow back to 8 ints on version change!)
		};

		struct mstudiomodelgroup_t
		{
			int					szlabelindex;	// textual name
			FString GetLabel() const { return szlabelindex > 0 ? ReadString(this, szlabelindex) : FString(); }
			int					sznameindex;	// file name
			FString GetName() const { return sznameindex > 0 ? ReadString(this, sznameindex) : FString(); }
		};

		struct mstudioattachment_t
		{
			int					sznameindex;
			FString GetName() const { return sznameindex > 0 ? ReadString(this, sznameindex) : FString(); }
			unsigned int		flags;
			int					localbone;
			float				local[12]; // attachment point
			int					unused[8];
		};

		struct studiohdr_t
		{
			int		id;		// Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
			int		version;	// Format version number, such as 48 (0x30,0x00,0x00,0x00)
			int		checksum;	// This has to be the same in the phy and vtx files to load!
			char	name[64];		// The internal name of the model, padding with null bytes.
							// Typically "my_model.mdl" will have an internal name of "my_model"
			int		dataLength;	// Data size of MDL file in bytes.

			// A vector is 12 bytes, three 4-byte float-values in a row.
			FVector		eyeposition;	// Position of player viewpoint relative to model origin
			FVector		illumposition;	// ?? Presumably the point used for lighting when per-vertex lighting is not enabled.
			FVector		hull_min;	// Corner of model hull box with the least X/Y/Z values
			FVector		hull_max;	// Opposite corner of model hull box
			FVector	  	view_bbmin;
			FVector	 	view_bbmax;

			int		flags;		// Binary flags in little-endian order. 
							// ex (00000001,00000000,00000000,11000000) means flags for position 0, 30, and 31 are set. 
							// Set model flags section for more information
			bool HasFlag(studiohdr_flag flag) const { return (flags & (int)flag) != 0; }

			/*
			 * After this point, the header contains many references to offsets
			 * within the MDL file and the number of items at those offsets.
			 *
			 * Offsets are from the very beginning of the file.
			 *
			 * Note that indexes/counts are not always paired and ordered consistently.
			 */

			 // mstudiobone_t
			int		bone_count;	// Number of data sections (of type mstudiobone_t)
			int		bone_offset;	// Offset of first data section
			void GetBones(TArray<const mstudiobone_t *>& out) const { ReadArray<mstudiobone_t>(this, bone_offset, bone_count, out); }

			// mstudiobonecontroller_t
			int		bonecontroller_count;
			int		bonecontroller_offset;

			// mstudiohitboxset_t
			int		hitbox_count;
			int		hitbox_offset;

			// mstudioanimdesc_t
			int		localanim_count;
			int		localanim_offset;
			void GetLocalAnims(TArray<const mstudioanimdesc_t*>& out) const { ReadArray<mstudioanimdesc_t>(this, localanim_offset, localanim_count, out); }

			// mstudioseqdesc_t
			int		localseq_count;
			int		localseq_offset;
			void GetLocalSequences(TArray<const mstudioseqdesc_t*>& out) const { ReadArray<mstudioseqdesc_t>(this, localseq_offset, localseq_count, out); }

			int		activitylistversion; // ??
			int		eventsindexed;	// ??

			// VMT texture filenames
			// mstudiotexture_t
			int		texture_count;
			int		texture_offset;
			void GetTextures(TArray<const mstudiotexture_t*>& out) const { ReadArray<mstudiotexture_t>(this, texture_offset, texture_count, out); }

			// This offset points to a series of ints.
				// Each int value, in turn, is an offset relative to the start of this header/the-file,
				// At which there is a null-terminated string.
			int		texturedir_count;
			int		texturedir_offset;
			void GetTextureDirs(TArray<FString>& out) const
			{
				TArray<int> offsets;
				ReadArray(this, texturedir_offset, texturedir_count, offsets);
				out.Reserve(offsets.Num());
				for (const int offset : offsets)
				{
					out.Add(ReadString(this, offset));
				}
			}

			// Each skin-family assigns a texture-id to a skin location
			int		skinreference_count;
			int		skinrfamily_count;
			int             skinreference_index;

			// mstudiobodyparts_t
			int		bodypart_count;
			int		bodypart_offset;
			void GetBodyParts(TArray<const mstudiobodyparts_t*>& out) const { ReadArray<mstudiobodyparts_t>(this, bodypart_offset, bodypart_count, out); }

			// Local attachment points		
		// 
			int		attachment_count;
			int		attachment_offset;
			void GetAttachments(TArray<const mstudioattachment_t*>& out) const { ReadArray<mstudioattachment_t>(this, attachment_offset, attachment_count, out); }

			// Node values appear to be single bytes, while their names are null-terminated strings.
			int		localnode_count;
			int		localnode_index;
			int		localnode_name_index;

			// mstudioflexdesc_t
			int		flexdesc_count;
			int		flexdesc_index;

			// mstudioflexcontroller_t
			int		flexcontroller_count;
			int		flexcontroller_index;

			// mstudioflexrule_t
			int		flexrules_count;
			int		flexrules_index;

			// IK probably referse to inverse kinematics
			// mstudioikchain_t
			int		ikchain_count;
			int		ikchain_index;

			// Information about any "mouth" on the model for speech animation
			// More than one sounds pretty creepy.
			// mstudiomouth_t
			int		mouths_count;
			int		mouths_index;

			// mstudioposeparamdesc_t
			int		localposeparam_count;
			int		localposeparam_index;

			/*
			 * For anyone trying to follow along, as of this writing,
			 * the next "surfaceprop_index" value is at position 0x0134 (308)
			 * from the start of the file.
			 */

			 // Surface property value (single null-terminated string)
			int		surfaceprop_index;
			FString GetSurfaceProp() const { return ReadString(this, surfaceprop_index); }

			// Unusual: In this one index comes first, then count.
			// Key-value data is a series of strings. If you can't find
			// what you're interested in, check the associated PHY file as well.
			int		keyvalue_index;
			int		keyvalue_count;
			void GetKeyValues(TArray<FString>& out) const { ReadArray(this, keyvalue_index, keyvalue_count, out); }

			// More inverse-kinematics
			// mstudioiklock_t
			int		iklock_count;
			int		iklock_index;


			float		mass; 		// Mass of object (4-bytes)
			int		contents;	// ??

			// Other models can be referenced for re-used sequences and animations
			// (See also: The $includemodel QC option.)
			// mstudiomodelgroup_t
			int		includemodel_count;
			int		includemodel_index;
			void GetIncludeModels(TArray<const mstudiomodelgroup_t*>& out) const { ReadArray<mstudiomodelgroup_t>(this, includemodel_index, includemodel_count, out); }

			int		virtualModel;	// Placeholder for mutable-void*

			// mstudioanimblock_t
			int		animblocks_name_index;
			int		animblocks_count;
			int		animblocks_index;
			const mstudioanimblock_t* GetAnimBlock(int index) const { check(index > 0 && index < animblocks_count); return (mstudioanimblock_t*)(((uint8*)this) + animblocks_index) + index; }
			void GetAnimBlocks(TArray<const mstudioanimblock_t*>& out) const { return ReadArray<mstudioanimblock_t>(this, animblocks_index, animblocks_count, out); }

			int		animblockModel; // Placeholder for mutable-void*

			// Points to a series of bytes?
			int		bonetablename_index;

			int		vertex_base;	// Placeholder for void*
			int		offset_base;	// Placeholder for void*

			// Used with $constantdirectionallight from the QC 
			// Model should have flag #13 set if enabled
			uint8		directionaldotproduct;

			uint8		rootLod;	// Preferred rather than clamped

			// 0 means any allowed, N means Lod 0 -> (N-1)
			uint8		numAllowedRootLods;

			uint8		unused0; // ??
			int		unused1; // ??

			// mstudioflexcontrollerui_t
			int		flexcontrollerui_count;
			int		flexcontrollerui_index;

			/**
			 * Offset for additional header information.
			 * May be zero if not present, or also 408 if it immediately
			 * follows this studiohdr_t
			 */
			 // studiohdr2_t
			int		studiohdr2index;

			int		unused2; // ??

			/**
			 * As of this writing, the header is 408 bytes long in total
			 */
		};

		struct studiohdr2_t
		{
			// ??
			int		srcbonetransform_count;
			int		srcbonetransform_index;

			int		illumpositionattachmentindex;

			float		flMaxEyeDeflection;	//  If set to 0, then equivalent to cos(30)

			// mstudiolinearbone_t
			int		linearbone_index;

			int 	unknown[64];
		};
	}
}
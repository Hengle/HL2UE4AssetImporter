#pragma once;

#include "CoreMinimal.h"
#include "utils.h"

//#pragma pack(1)

namespace Valve
{
	namespace MDL
	{
		constexpr int MAX_NUM_LODS = 8;

		enum class studiohdr_flag : int
		{
			// This flag is set if no hitbox information was specified
			AUTOGENERATED_HITBOX = 1 << 0,
			// This flag is set at loadtime, not mdl build time so that we don't have to rebuild models when we change materials.
			USES_ENV_CUBEMAP = 1 << 1,
			// Use this when there are translucent parts to the model but we're not going to sort it.
			FORCE_OPAQUE = 1 << 2,
			// Use this when we want to render the opaque parts during the opaque pass and the translucent parts during the translucent pass.Added using $mostlyopaque to the QC.
			TRANSLUCENT_TWOPASS = 1 << 3,
			// This is set any time the.qc files has $staticprop in it.Means there's no bones and no transforms.
			STATIC_PROP = 1 << 4,
			// This flag is set at loadtime, not mdl build time so that we don't have to rebuild models when we change materials.
			USES_FB_TEXTURE = 1 << 5,
			// This flag is set by studiomdl.exe if a separate "$shadowlod" entry was present for the.mdl(the shadow lod is the last entry in the lod list if present).
			HASSHADOWLOD = 1 << 6,
			// This flag is set at loadtime, not mdl build time so that we don't have to rebuild models when we change materials.
			USES_BUMPMAPPING = 1 << 7,
			// This flag is set when we should use the actual materials on the shadow LOD instead of overriding them with the default one(necessary for translucent shadows).
			USE_SHADOWLOD_MATERIALS = 1 << 8,
			OBSOLETE = 1 << 9,
			UNUSED = 1 << 10,
			// This flag is set at mdl build time.
			NO_FORCED_FADE = 1 << 11,
			// The npc will lengthen the viseme check to always include two phonemes.
			FORCE_PHONEME_CROSSFADE = 1 << 12,
			// This flag is set when the.qc has $constantdirectionallight in it.If set, we use constantdirectionallightdot to calculate light intensity rather than the normal directional dot product.Only valid if STUDIOHDR_FLAGS_STATIC_PROP is also set.
			CONSTANT_DIRECTIONAL_LIGHT_DOT = 1 << 13,
			// Flag to mark delta flexes as already converted from disk format to memory format.
			FLEXES_CONVERTED = 1 << 14,
			// Indicates the studiomdl was built in preview mode(added with the - preview flag).
			BUILT_IN_PREVIEW_MODE = 1 << 15,
			// Ambient boost(runtime flag).
			AMBIENT_BOOST = 1 << 16,
			// Don't cast shadows from this model (useful on first-person models).
			DO_NOT_CAST_SHADOWS = 1 << 17,
			// Alpha textures should cast shadows in vrad on this model(ONLY prop_static!).Requires setup in the lights.rad file.
			CAST_TEXTURE_SHADOWS = 1 << 18
		};

		struct mstudiobone_t
		{
			int					sznameindex;
			FString GetName() const { return ReadString(this, sznameindex); }

			int		 			parent;		// parent bone
			int					bonecontroller[6];	// bone controller index, -1 == none

			// default values
			float			pos[3];
			float			quat[4];
			float			rot[3];
			// compression scale
			float				posscale[3];
			float				rotscale[3];

			float			poseToBone[12]; // 3x4 matrix
			float			qAlignment[4];
			int					flags;
			int					proctype;
			int					procindex;		// procedural rule
			int					physicsbone;	// index into physically simulated bone
			int					surfacepropidx;	// index into string tablefor property name
			int					contents;		// See BSPFlags.h for the contents flags

			int					unused[8];		// remove as appropriate
		};

		struct mstudiotexture_t
		{
			// Number of bytes past the beginning of this structure
			// where the first character of the texture name can be found.
			int		name_offset; 	// Offset for null-terminated string
			FString GetName() const { return ReadString(this, name_offset); }

			int		flags;
			int		used; 		// ??

			int		unused0; 	// ??

			int	material;		// Placeholder for IMaterial
			int	client_material;	// Placeholder for void*

			int		unused1[10];
		};

		struct mstudio_modelvertexdata_t
		{
			// base of external vertex data stores
			int pVertexData;
			int pTangentData;
		};

		struct mstudio_meshvertexdata_t
		{
			// indirection to this mesh's model's vertex data
			int modelvertexdata;

			// used for fixup calcs when culling top level lods
			// expected number of mesh verts at desired lod
			int					numLODVertexes[MAX_NUM_LODS];
		};

		struct mstudiomesh_t
		{
			int					material;

			int					modelindex;

			int					numvertices;		// number of unique vertices/normals/texcoords
			int					vertexoffset;		// vertex mstudiovertex_t

			int					numflexes;			// vertex animation
			int					flexindex;
			// inline mstudioflex_t* pFlex(int i) const { return (mstudioflex_t*)(((byte*)this) + flexindex) + i; };

			// special codes for material operations
			int					materialtype;
			int					materialparam;

			// a unique ordinal for this mesh
			int					meshid;

			FVector				center;

			mstudio_meshvertexdata_t vertexdata;

			int					unused[8]; // remove as appropriate
		};

		struct mstudiomodel_t
		{
			char				name[64];
			FString GetName() const { return ReadString(this, 0); }

			int					type;

			float				boundingradius;

			int					nummeshes;
			int					meshindex;
			void GetMeshes(TArray<const mstudiomesh_t*>& out) const { return ReadArray<mstudiomesh_t>(this, meshindex, nummeshes, out); }

			// cache purposes
			int					numvertices;		// number of unique vertices/normals/texcoords
			int					vertexindex;		// vertex Vector
			int					tangentsindex;		// tangents Vector

			int					numattachments;
			int					attachmentindex;

			int					numeyeballs;
			int					eyeballindex;
			// inline  mstudioeyeball_t* pEyeball(int i) { return (mstudioeyeball_t*)(((byte*)this) + eyeballindex) + i; };

			mstudio_modelvertexdata_t vertexdata;

			int					unused[8];		// remove as appropriate
		};

		struct mstudiobodyparts_t
		{
			int					sznameindex;
			FString GetName() const { return ReadString(this, sznameindex); }
			int					nummodels;
			int					base;
			int					modelindex; // index into models array
			void GetModels(TArray<const mstudiomodel_t*>& out) const { return ReadArray<mstudiomodel_t>(this, modelindex, nummodels, out); }
		};

		struct studiohdr_t
		{
			int		id;		// Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
			int		version;	// Format version number, such as 48 (0x30,0x00,0x00,0x00)
			int		checksum;	// This has to be the same in the phy and vtx files to load!
			char	name[64];		// The internal name of the model, padding with null bytes.
							// Typically "my_model.mdl" will have an internal name of "my_model"
			int		dataLength;	// Data size of MDL file in bytes.

			// A vector is 12 bytes, three 4-byte float-values in a row.
			FVector		eyeposition;	// Position of player viewpoint relative to model origin
			FVector		illumposition;	// ?? Presumably the point used for lighting when per-vertex lighting is not enabled.
			FVector		hull_min;	// Corner of model hull box with the least X/Y/Z values
			FVector		hull_max;	// Opposite corner of model hull box
			FVector	  	view_bbmin;
			FVector	 	view_bbmax;

			int		flags;		// Binary flags in little-endian order. 
							// ex (00000001,00000000,00000000,11000000) means flags for position 0, 30, and 31 are set. 
							// Set model flags section for more information
			bool HasFlag(studiohdr_flag flag) const { return (flags & (int)flag) != 0; }

			/*
			 * After this point, the header contains many references to offsets
			 * within the MDL file and the number of items at those offsets.
			 *
			 * Offsets are from the very beginning of the file.
			 *
			 * Note that indexes/counts are not always paired and ordered consistently.
			 */

			 // mstudiobone_t
			int		bone_count;	// Number of data sections (of type mstudiobone_t)
			int		bone_offset;	// Offset of first data section
			void GetBones(TArray<const mstudiobone_t *>& out) const { ReadArray<mstudiobone_t>(this, bone_offset, bone_count, out); }

			// mstudiobonecontroller_t
			int		bonecontroller_count;
			int		bonecontroller_offset;

			// mstudiohitboxset_t
			int		hitbox_count;
			int		hitbox_offset;

			// mstudioanimdesc_t
			int		localanim_count;
			int		localanim_offset;

			// mstudioseqdesc_t
			int		localseq_count;
			int		localseq_offset;

			int		activitylistversion; // ??
			int		eventsindexed;	// ??

			// VMT texture filenames
			// mstudiotexture_t
			int		texture_count;
			int		texture_offset;
			void GetTextures(TArray<const mstudiotexture_t*>& out) const { ReadArray<mstudiotexture_t>(this, texture_offset, texture_count, out); }

			// This offset points to a series of ints.
				// Each int value, in turn, is an offset relative to the start of this header/the-file,
				// At which there is a null-terminated string.
			int		texturedir_count;
			int		texturedir_offset;
			void GetTextureDirs(TArray<FString>& out) const
			{
				TArray<int> offsets;
				ReadArray(this, texturedir_offset, texturedir_count, offsets);
				out.Reserve(offsets.Num());
				for (const int offset : offsets)
				{
					out.Add(ReadString(this, offset));
				}
			}

			// Each skin-family assigns a texture-id to a skin location
			int		skinreference_count;
			int		skinrfamily_count;
			int             skinreference_index;

			// mstudiobodyparts_t
			int		bodypart_count;
			int		bodypart_offset;
			void GetBodyParts(TArray<const mstudiobodyparts_t*>& out) const { ReadArray<mstudiobodyparts_t>(this, bodypart_offset, bodypart_count, out); }

			// Local attachment points		
		// mstudioattachment_t
			int		attachment_count;
			int		attachment_offset;

			// Node values appear to be single bytes, while their names are null-terminated strings.
			int		localnode_count;
			int		localnode_index;
			int		localnode_name_index;

			// mstudioflexdesc_t
			int		flexdesc_count;
			int		flexdesc_index;

			// mstudioflexcontroller_t
			int		flexcontroller_count;
			int		flexcontroller_index;

			// mstudioflexrule_t
			int		flexrules_count;
			int		flexrules_index;

			// IK probably referse to inverse kinematics
			// mstudioikchain_t
			int		ikchain_count;
			int		ikchain_index;

			// Information about any "mouth" on the model for speech animation
			// More than one sounds pretty creepy.
			// mstudiomouth_t
			int		mouths_count;
			int		mouths_index;

			// mstudioposeparamdesc_t
			int		localposeparam_count;
			int		localposeparam_index;

			/*
			 * For anyone trying to follow along, as of this writing,
			 * the next "surfaceprop_index" value is at position 0x0134 (308)
			 * from the start of the file.
			 */

			 // Surface property value (single null-terminated string)
			int		surfaceprop_index;
			FString GetSurfaceProp() const { return ReadString(this, surfaceprop_index); }

			// Unusual: In this one index comes first, then count.
			// Key-value data is a series of strings. If you can't find
			// what you're interested in, check the associated PHY file as well.
			int		keyvalue_index;
			int		keyvalue_count;
			void GetKeyValues(TArray<FString>& out) const { ReadArray(this, keyvalue_index, keyvalue_count, out); }

			// More inverse-kinematics
			// mstudioiklock_t
			int		iklock_count;
			int		iklock_index;


			float		mass; 		// Mass of object (4-bytes)
			int		contents;	// ??

			// Other models can be referenced for re-used sequences and animations
			// (See also: The $includemodel QC option.)
			// mstudiomodelgroup_t
			int		includemodel_count;
			int		includemodel_index;

			int		virtualModel;	// Placeholder for mutable-void*

			// mstudioanimblock_t
			int		animblocks_name_index;
			int		animblocks_count;
			int		animblocks_index;

			int		animblockModel; // Placeholder for mutable-void*

			// Points to a series of bytes?
			int		bonetablename_index;

			int		vertex_base;	// Placeholder for void*
			int		offset_base;	// Placeholder for void*

			// Used with $constantdirectionallight from the QC 
			// Model should have flag #13 set if enabled
			uint8		directionaldotproduct;

			uint8		rootLod;	// Preferred rather than clamped

			// 0 means any allowed, N means Lod 0 -> (N-1)
			uint8		numAllowedRootLods;

			uint8		unused0; // ??
			int		unused1; // ??

			// mstudioflexcontrollerui_t
			int		flexcontrollerui_count;
			int		flexcontrollerui_index;

			/**
			 * Offset for additional header information.
			 * May be zero if not present, or also 408 if it immediately
			 * follows this studiohdr_t
			 */
			 // studiohdr2_t
			int		studiohdr2index;

			int		unused2; // ??

			/**
			 * As of this writing, the header is 408 bytes long in total
			 */
		};

		struct studiohdr2_t
		{
			// ??
			int		srcbonetransform_count;
			int		srcbonetransform_index;

			int		illumpositionattachmentindex;

			float		flMaxEyeDeflection;	//  If set to 0, then equivalent to cos(30)

			// mstudiolinearbone_t
			int		linearbone_index;

			int 	unknown[64];
		};
	}
}

//#pragma pack()